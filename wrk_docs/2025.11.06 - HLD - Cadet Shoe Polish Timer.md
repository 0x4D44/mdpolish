# High-Level Design: Cadet Shoe Polish Timer

**Date:** 2025-11-06
**Version:** 1.0
**Status:** Draft

## 1. Overview

### 1.1 Purpose
A cross-platform timer application designed to help cadets track their shoe polishing sessions. The app provides interval-based timing with session tracking to encourage thorough and consistent polishing routines.

### 1.2 Goals
- Provide a simple, distraction-free timer interface
- Track polishing effort through iteration counts and total time
- Support configurable timer durations
- Deliver a modern, clean user experience
- Work seamlessly on both web browsers and Android devices

### 1.3 Non-Goals (YAGNI)
- User accounts or cloud sync (can add later if needed)
- Multiple concurrent timers
- Social features or sharing
- Complex analytics or reports
- iOS support (not requested, can add later)

## 2. Requirements

### 2.1 Functional Requirements

**FR-1: Timer Functionality**
- Timer runs for a configurable duration (default: 3 minutes)
- Timer displays remaining time in MM:SS format
- Visual and audio notification when timer completes
- Timer can be paused and resumed
- Timer can be reset

**FR-2: Iteration Tracking**
- "Next Iteration" button appears when timer completes
- Each completed timer increments iteration counter
- Iteration count persists during active session
- Clear visual display of current iteration count

**FR-3: Time Tracking**
- Total time accumulates across all completed iterations
- Display total time in human-readable format (e.g., "15 mins" or "1h 30m")
- Time only accumulates when timer is actively running

**FR-4: Configuration**
- User can set custom timer duration
- Duration persists across app sessions
- Configuration accessible but not intrusive

**FR-5: Session Management**
- "Start New Session" resets iteration count and total time
- Current session state persists if app is closed/backgrounded
- Option to view session history (iterations and time)

### 2.2 Non-Functional Requirements

**NFR-1: Performance**
- Timer accuracy within 1 second over 3-minute period
- App responds to user input within 100ms
- Minimal battery drain on Android

**NFR-2: Usability**
- Interface usable with one hand
- All critical controls accessible without scrolling
- Large touch targets (minimum 44x44pt)
- Clear visual hierarchy

**NFR-3: Reliability**
- Timer continues running when app is backgrounded (Android)
- Timer state recovers correctly after device rotation
- No data loss during normal app lifecycle

**NFR-4: Aesthetics**
- Modern, clean design
- Sufficient contrast for outdoor/variable lighting
- Consistent design language across platforms

## 3. Technology Stack

### 3.1 Recommended Approach: React Native + TypeScript

**Rationale:**
- Single codebase for web and Android
- TypeScript provides type safety and better developer experience
- Large ecosystem and community support
- Native performance for Android
- Can deploy web version via React Native Web

**Stack Components:**
- **Framework:** React Native 0.73+
- **Language:** TypeScript 5.x
- **Build Tool:** Expo (recommended for easier setup and OTA updates)
- **State Management:** React Context + Hooks (sufficient for this app's complexity)
- **Storage:** AsyncStorage for React Native, LocalStorage for web
- **Styling:** React Native StyleSheet with design tokens
- **Navigation:** React Navigation (if multi-screen needed)
- **Testing:** Jest + React Native Testing Library

**Alternative Considered:**
- Separate implementations (React + TypeScript for web, Kotlin for Android)
  - Rejected: Duplicates effort, harder to maintain consistency
  - Would only consider if native features are critical

### 3.2 Development Environment
- **IDE:** VS Code with React Native extensions
- **Version Control:** Git
- **Package Manager:** npm or yarn
- **Linting:** ESLint with TypeScript rules
- **Formatting:** Prettier

## 4. Architecture

### 4.1 Application Structure

```
polish-timer/
├── src/
│   ├── components/        # Reusable UI components
│   │   ├── Timer.tsx
│   │   ├── Controls.tsx
│   │   ├── Stats.tsx
│   │   └── Settings.tsx
│   ├── screens/           # Main app screens
│   │   ├── TimerScreen.tsx
│   │   └── HistoryScreen.tsx (optional)
│   ├── hooks/             # Custom React hooks
│   │   ├── useTimer.ts
│   │   └── useStorage.ts
│   ├── context/           # React Context for state
│   │   └── SessionContext.tsx
│   ├── types/             # TypeScript type definitions
│   │   └── index.ts
│   ├── utils/             # Utility functions
│   │   ├── time.ts
│   │   └── storage.ts
│   ├── theme/             # Design tokens and styling
│   │   ├── colors.ts
│   │   ├── spacing.ts
│   │   └── typography.ts
│   └── App.tsx            # Root component
├── android/               # Android-specific code
├── web/                   # Web-specific code
└── tests/                 # Test files
```

### 4.2 Component Architecture

```
App
└── SessionProvider (Context)
    └── TimerScreen
        ├── Timer (Display)
        ├── Controls (Start/Pause/Reset/Next)
        ├── Stats (Iterations, Total Time)
        └── Settings (Modal/Drawer)
```

### 4.3 State Management

**Application State:**
- Timer state (running, paused, completed, idle)
- Current time remaining (seconds)
- Current iteration number
- Total time accumulated (seconds)
- Timer duration setting (seconds)
- Session start timestamp

**State Flow:**
```
User Action → Component → Context Update → Re-render → UI Update
                              ↓
                         Persist to Storage
```

## 5. Data Model

### 5.1 Core Types

```typescript
// Session represents an active or completed polishing session
interface Session {
  id: string;                    // UUID
  startTime: number;             // Unix timestamp
  endTime?: number;              // Unix timestamp (if completed)
  iterations: number;            // Count of completed iterations
  totalTimeSeconds: number;      // Accumulated active time
  timerDurationSeconds: number;  // Duration setting used for this session
}

// TimerState represents the current state of the timer
interface TimerState {
  status: 'idle' | 'running' | 'paused' | 'completed';
  remainingSeconds: number;
  currentIteration: number;
}

// AppConfig stores user preferences
interface AppConfig {
  timerDurationSeconds: number;  // Default: 180 (3 minutes)
  soundEnabled: boolean;         // Default: true
  vibrationEnabled: boolean;     // Default: true (Android only)
}

// SessionHistory for optional historical tracking
interface SessionHistory {
  sessions: Session[];
  totalIterations: number;
  totalTimeSeconds: number;
}
```

### 5.2 Storage Schema

**AsyncStorage Keys:**
- `@polish_timer:current_session` - Active session data
- `@polish_timer:config` - User configuration
- `@polish_timer:history` - Session history (optional feature)

### 5.3 State Persistence Strategy

**When to Persist:**
- Configuration: On every change
- Current session: On timer state changes (start, pause, complete iteration)
- History: On session completion

**Recovery Strategy:**
- On app launch, check for existing session
- If session exists and was active < 1 hour ago, offer to resume
- If session is older, offer to start fresh or view stats

## 6. UI/UX Design

### 6.1 Screen Layout

**Primary Screen (Timer View):**

```
┌─────────────────────────────────┐
│  [Settings Icon]     Polish Timer│  <- Header
├─────────────────────────────────┤
│                                  │
│          Iteration 3             │  <- Current iteration
│                                  │
│         ┌───────────┐           │
│         │   02:47   │           │  <- Large timer display
│         └───────────┘           │
│                                  │
│      [  Start/Pause  ]          │  <- Primary action button
│      [    Reset     ]           │  <- Secondary action
│                                  │
├─────────────────────────────────┤
│  Total Iterations: 2             │  <- Stats section
│  Total Time: 6 mins              │
└─────────────────────────────────┘
```

**Settings Modal:**
```
┌─────────────────────────────────┐
│  Settings                    [X] │
├─────────────────────────────────┤
│                                  │
│  Timer Duration                  │
│  [ 3 ] minutes                   │
│                                  │
│  Sound Notifications   [Toggle]  │
│  Vibration (Android)   [Toggle]  │
│                                  │
│  [  New Session  ]              │
│  [  View History ]              │
│                                  │
│         [  Save  ]               │
└─────────────────────────────────┘
```

### 6.2 Visual Design Principles

**Color Scheme:**
- Primary: Deep Navy Blue (#1a237e) - Professional, military aesthetic
- Accent: Bright Gold (#ffd700) - Represents shine/polish
- Success: Green (#4caf50) - Completed iterations
- Background: Off-white (#fafafa) / Dark mode: (#121212)
- Text: High contrast (Black on light, White on dark)

**Typography:**
- Timer: Large, monospace font (72pt+)
- Headers: Bold, sans-serif (24pt)
- Body: Regular, sans-serif (16pt)
- Stats: Medium weight, sans-serif (18pt)

**Spacing:**
- Use 8pt grid system
- Minimum touch targets: 48x48pt
- Generous padding around timer (40pt+)

**Animations:**
- Timer updates: Smooth transitions
- Button press: Subtle scale feedback
- Completion: Celebration animation (optional, subtle)
- State transitions: 200-300ms ease curves

### 6.3 User Flows

**Flow 1: First Time User**
1. Opens app → Sees timer in idle state with 3:00
2. Taps "Start" → Timer begins counting down
3. Continues polishing while timer runs
4. Timer completes → Sound/vibration, button changes to "Next Iteration"
5. Taps "Next" → Iteration increments, timer resets and auto-starts
6. Repeats as needed

**Flow 2: Changing Timer Duration**
1. Taps settings icon
2. Changes duration to desired value
3. Taps save
4. Returns to timer screen with new duration

**Flow 3: Starting New Session**
1. Taps settings
2. Taps "New Session"
3. Confirms action
4. Stats reset, timer returns to idle state

## 7. Component Specifications

### 7.1 Timer Component

**Responsibilities:**
- Display remaining time in MM:SS format
- Update every second when running
- Provide visual feedback for different states

**Props:**
```typescript
interface TimerProps {
  remainingSeconds: number;
  status: TimerState['status'];
}
```

**Behavior:**
- Running: Updates display every second, subtle pulse animation
- Paused: Static display, dimmed appearance
- Completed: Shows "00:00", success color
- Idle: Shows configured duration

### 7.2 Controls Component

**Responsibilities:**
- Provide timer control buttons
- Adapt button labels based on timer state
- Handle user interactions

**Props:**
```typescript
interface ControlsProps {
  status: TimerState['status'];
  onStart: () => void;
  onPause: () => void;
  onReset: () => void;
  onNextIteration: () => void;
}
```

**Button States:**
- Idle: "Start" (primary), "Settings" (secondary)
- Running: "Pause" (primary), "Reset" (secondary)
- Paused: "Resume" (primary), "Reset" (secondary)
- Completed: "Next Iteration" (primary), "New Session" (secondary)

### 7.3 Stats Component

**Responsibilities:**
- Display current session statistics
- Format time in human-readable way

**Props:**
```typescript
interface StatsProps {
  iterations: number;
  totalTimeSeconds: number;
}
```

**Display Logic:**
- Iterations: Simple count
- Total Time:
  - < 60s: "X secs"
  - < 3600s: "X mins"
  - >= 3600s: "Xh Ym"

### 7.4 Settings Component

**Responsibilities:**
- Allow duration configuration
- Provide session management options
- Persist configuration changes

**Props:**
```typescript
interface SettingsProps {
  config: AppConfig;
  onConfigChange: (config: AppConfig) => void;
  onNewSession: () => void;
  onViewHistory: () => void;
}
```

## 8. Custom Hooks

### 8.1 useTimer Hook

```typescript
interface UseTimerReturn {
  state: TimerState;
  start: () => void;
  pause: () => void;
  reset: () => void;
  complete: () => void;
}

function useTimer(durationSeconds: number): UseTimerReturn;
```

**Responsibilities:**
- Manage timer countdown logic
- Handle start/pause/reset/complete actions
- Use `setInterval` for countdown
- Clean up intervals on unmount

**Implementation Notes:**
- Use `useRef` to store interval ID
- Use `useEffect` for cleanup
- Emit events when timer completes

### 8.2 useStorage Hook

```typescript
interface UseStorageReturn<T> {
  data: T | null;
  loading: boolean;
  error: Error | null;
  save: (data: T) => Promise<void>;
  remove: () => Promise<void>;
}

function useStorage<T>(key: string): UseStorageReturn<T>;
```

**Responsibilities:**
- Abstract AsyncStorage/LocalStorage differences
- Provide loading and error states
- Handle JSON serialization/deserialization

## 9. Implementation Phases

### Phase 1: Core Timer Functionality (MVP)
**Goal:** Basic working timer with iteration tracking

**Tasks:**
1. Set up React Native project with TypeScript
2. Implement Timer component with countdown logic
3. Implement Controls component with start/pause/reset
4. Implement Stats component with iteration and time display
5. Add basic styling following design principles
6. Test timer accuracy and state management

**Acceptance Criteria:**
- Timer counts down accurately from 3 minutes
- Start/pause/reset work correctly
- Iteration count increments on completion
- Total time accumulates correctly
- UI is clear and usable

### Phase 2: Configuration & Persistence
**Goal:** Configurable duration with persistent state

**Tasks:**
1. Implement Settings component
2. Implement configuration storage
3. Implement session state persistence
4. Add session recovery on app launch
5. Test storage and recovery scenarios

**Acceptance Criteria:**
- User can change timer duration
- Settings persist across app restarts
- Active session recovers correctly
- Configuration UI is intuitive

### Phase 3: Polish & Platform Support
**Goal:** Modern UI, Android optimization, web deployment

**Tasks:**
1. Implement final visual design
2. Add animations and transitions
3. Add sound and vibration notifications
4. Optimize for Android (background timers, notifications)
5. Set up web build with React Native Web
6. Test on physical Android device
7. Test web deployment

**Acceptance Criteria:**
- App looks modern and polished
- Animations are smooth and purposeful
- Timer works when app is backgrounded (Android)
- Web version works in modern browsers
- All interactions feel responsive

### Phase 4: Enhanced Features (Optional)
**Goal:** Session history and additional convenience features

**Tasks:**
1. Implement session history storage
2. Add history view screen
3. Add session completion summary
4. Add basic statistics (avg time per iteration, etc.)
5. Consider dark mode support

**Acceptance Criteria:**
- Users can view past sessions
- Historical data persists correctly
- Statistics are accurate and meaningful

## 10. Testing Strategy

### 10.1 Unit Tests

**Timer Logic:**
- Countdown decrements correctly each second
- Start/pause/reset work in all states
- Timer completion triggers correct events
- Edge cases (rapid start/stop, multiple resets)

**Storage:**
- Data serializes/deserializes correctly
- Error handling for storage failures
- Data migration if schema changes

**Utilities:**
- Time formatting functions
- State transition logic

### 10.2 Component Tests

**Components:**
- Timer renders correctly in all states
- Controls show correct buttons for each state
- Stats display correct values
- Settings update configuration correctly

**User Interactions:**
- Button clicks trigger correct actions
- Form inputs update state
- Modal/drawer open and close

### 10.3 Integration Tests

**Scenarios:**
- Complete full timer iteration
- Pause and resume timer
- Change settings mid-session
- Start new session
- App backgrounding and foregrounding (Android)
- Device rotation

### 10.4 Manual Testing Checklist

**Functionality:**
- [ ] Timer counts down accurately over 10+ minutes
- [ ] Iteration count increments correctly
- [ ] Total time accumulates correctly
- [ ] Settings persist across app restarts
- [ ] Session recovers after force close
- [ ] Sound/vibration work on completion

**Usability:**
- [ ] All controls are easily tappable
- [ ] Text is readable in various lighting
- [ ] Layout works on different screen sizes
- [ ] App responds quickly to all inputs
- [ ] No confusing UI states

**Platform-Specific (Android):**
- [ ] Timer continues when backgrounded
- [ ] Battery usage is reasonable
- [ ] Notifications work correctly
- [ ] Back button behavior is intuitive

**Platform-Specific (Web):**
- [ ] Works in Chrome, Firefox, Safari
- [ ] Responsive layout for different screen sizes
- [ ] PWA installation works (if implemented)

## 11. Deployment Strategy

### 11.1 Android Deployment

**Build Process:**
```bash
# Generate signed APK/AAB
eas build --platform android --profile production

# Or using standard React Native
cd android && ./gradlew assembleRelease
```

**Distribution Options:**
1. **Google Play Store** (Recommended for easy updates)
   - Create Play Console account
   - Upload signed AAB
   - Provide screenshots and description
   - Set up for production release

2. **Direct APK Distribution**
   - Build signed APK
   - Share directly with user
   - Simpler but no automatic updates

**App Signing:**
- Generate keystore for signing
- Store keystore credentials securely (not in git!)
- Use same keystore for all releases

### 11.2 Web Deployment

**Build Process:**
```bash
# Using Expo
expo build:web

# Or configure React Native Web
npm run build:web
```

**Hosting Options:**
1. **Static Site Hosting** (Recommended)
   - Netlify, Vercel, or GitHub Pages
   - Free tier available
   - Automatic HTTPS
   - Easy deployment from git

2. **Self-Hosted**
   - Build static assets
   - Serve from any web server
   - Configure proper caching headers

**PWA Configuration (Optional):**
- Add manifest.json
- Configure service worker for offline support
- Enable "Add to Home Screen" on mobile browsers

### 11.3 Version Management

**Versioning Scheme:** Semantic Versioning (X.Y.Z)
- Major (X): Breaking changes or major new features
- Minor (Y): New features, backwards compatible
- Patch (Z): Bug fixes

**Initial Release:** 1.0.0

## 12. Future Enhancements (Post-MVP)

**Potential Features (if requested):**
- Session templates (different durations for different shoes)
- Reminders to polish regularly
- Achievement system for motivation
- Photo progress tracking
- Multi-shoe tracking (left/right, multiple pairs)
- Cloud sync between devices
- Share sessions/achievements
- Integration with calendar
- Spotify/music controls during sessions
- Apple Watch companion app

**Do NOT implement these without explicit request.**

## 13. Security & Privacy Considerations

**Data Privacy:**
- All data stored locally on device
- No analytics or tracking (unless explicitly added)
- No network requests (unless cloud sync added)
- No personal information collected

**Code Security:**
- No sensitive data in source code
- No hardcoded secrets
- Proper input validation on configuration
- Safe type handling with TypeScript

## 14. Accessibility Considerations

**Visual:**
- High contrast color schemes
- Scalable text (respect system font size)
- Clear visual hierarchy
- No color-only information (use text labels)

**Motor:**
- Large touch targets (48x48pt minimum)
- No critical gestures (swipe, pinch)
- Buttons have enough spacing

**Auditory:**
- Optional audio notifications
- Visual alternatives for all audio cues

**Platform Features:**
- Support screen readers (proper ARIA labels on web)
- Respect system accessibility settings
- Test with Android TalkBack

## 15. Open Questions & Decisions Needed

**Questions for Arthur:**

1. **Platform Priority:** Should we prioritize Android or web first, or develop both in parallel?

2. **Distribution:** For Android, prefer Google Play Store or direct APK distribution?

3. **Session History:** Is historical tracking important for v1, or can it wait for v2?

4. **Notifications:** Should Android show a persistent notification while timer is running (allows background operation)?

5. **Branding:** Any specific color preferences or military/cadet branding to incorporate?

6. **Additional Features:** Any other features you envision that weren't mentioned?

## 16. Risks & Mitigation

**Risk: Timer inaccuracy over long sessions**
- Mitigation: Use system time instead of interval counting
- Testing: Verify accuracy over 30+ minute sessions

**Risk: Battery drain on Android**
- Mitigation: Use efficient wake locks, minimize background work
- Testing: Monitor battery usage with Android Battery Historian

**Risk: State loss on Android**
- Mitigation: Persist state frequently, implement proper lifecycle handling
- Testing: Test force-close, low memory, and battery optimization scenarios

**Risk: Cross-platform inconsistencies**
- Mitigation: Test extensively on both platforms, use platform-specific code sparingly
- Testing: Maintain test devices/emulators for both platforms

**Risk: Over-engineering for simple use case**
- Mitigation: Follow YAGNI, implement MVP first, add features only when needed
- Review: Regular check-ins on scope and complexity

## 17. Success Metrics

**How we'll know this is successful:**

1. **Functional Success:**
   - Timer accuracy within 1 second over 3-minute period
   - Zero crashes during normal usage
   - State persists correctly 100% of the time

2. **Usability Success:**
   - User can complete a full polishing session without confusion
   - All primary actions accessible within one tap
   - Positive feedback from user (Arthur's son)

3. **Technical Success:**
   - Test coverage > 80%
   - Clean build with no warnings
   - Passes ESLint and Prettier checks
   - Compiles with no TypeScript errors

## 18. Timeline Estimate

**Phase 1 (MVP):** 2-3 days
- Day 1: Project setup, core timer logic
- Day 2: UI components, basic styling
- Day 3: Testing, bug fixes

**Phase 2 (Config & Persistence):** 1-2 days
- Settings implementation
- Storage layer
- Testing

**Phase 3 (Polish & Deploy):** 2-3 days
- Final design implementation
- Platform optimization
- Deployment setup
- Comprehensive testing

**Phase 4 (Optional Features):** 1-2 days per feature

**Total MVP to Production:** 5-8 days of development

## 19. References & Resources

**React Native Documentation:**
- https://reactnative.dev/docs/getting-started
- https://reactnative.dev/docs/asyncstorage

**React Native Web:**
- https://necolas.github.io/react-native-web/

**Expo Documentation:**
- https://docs.expo.dev/

**Design Resources:**
- Material Design (Android guidelines)
- Human Interface Guidelines (general mobile UX)

**Testing:**
- Jest: https://jestjs.io/
- React Native Testing Library: https://callstack.github.io/react-native-testing-library/

---

**Document Status:** Ready for Review
**Next Steps:** Review with Arthur, address open questions, begin Phase 1 implementation upon approval
